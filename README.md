# Mirror-Encryptor
<br />
<br />
Simple Encryptor by generate a .mirror_key file and a .enc file
<br />
<br />

# What does it do ?
<br />
<br />
This program is an encryptor that can seperate file into encrypted part and key part. You can transfer them with two different method and decrypt the original file to make file transfer secure.
<br />
<br />

# How to build ?
<br />
<br />
Build with cmake
<br />
<br />
Make sure your OS has installed CMAKE and A C COMPILER.
<br />
<br />
Type:

    cd /THIS/PROJECT/PATH/
    mkdir build
    cmake -B build
<br />
<br />
Switch to build directory and build it with your compiler
<br />
<br />
<br />
<br />
Build with GNU Makefile (Linux ONLY)
<br />
<br />
Type:

    make        #build
    make cl     #remove
<br />
<br />
<br />
<br />
<br />

# How to use ?
<br />
<br />
To generate a key, Type:

    ./genkey file-name
<br />
<br />
This will generate a key file called "file-name.mirror_key"
<br />
<br />
To encrypt this file, Type:

    ./encrypt file-name file-name.mirror_key
<br />
<br />
This will generate an encrypted file called "file-name.enc"
<br />
<br />
To get the original file, Type:

    ./decrypt file-name.enc file-name.mirror_key
<br />
<br />
This will generate the original file.
<br />
<br />
This program will check if your input file is correct. It can also show the similarity percentage with the original file to let user decide if it's secure enough to transfer.
<br />
<br />

# Similarity Percentage ? Why ? Is it really secure ?
<br />
<br />
Before answering your question, I'll explain how this program works.
<br />
<br />
The "Mirror Key" part, that key file you generated, contains TWO data type. One is called "Length Byte", Another is called "Mirror Byte". The "Length Byte" represent a number between 0 to 255(max size of a byte). The summary of all "Length Byte"s is the size of your file in Byte(B). And the "Mirror Byte" is random bytes generated by your operating system when calling "srand(time(0))" function and "rand()%0x100" function.
<br />
<br />
The content of "Mirror Key" combines them together. A "Length Byte", A "Mirror Byte" , A "Length Byte", A "Mirror Byte" , A "Length Byte", A "Mirror Byte"......  This is the binary format it contains.
<br />
<br />
When encrypting, your file is separated into pieces, the length of each piece is the number of each "Length Byte", from 1(0 is avoided by "continue" expression) to 255. each pieces is "Mirrored" by the "Mirror Byte".
<br />
<br />
Let me explain how it works:

    For example, there's a random part of data from "Mirror Key" like this (0x is the symbol of hexadecimal):
                             +------+------+
                             | 0x05 | 0x2f |
                             +------+------+
    And Let's suppose the "0x05" is the "Length Byte" and the "0x2f" is the "Mirror Byte".
    
    The program will grab a 5-byte piece from your file because the "Length Byte" equals to 5. Suppose the piece looks like this:
                   +------+------+------+------+------+
                   | 0x12 | 0x34 | 0x88 | 0x2f | 0x1a |
                   +------+------+------+------+------+
                   
    Then the program will calculate distance between "Mirror Byte" and each Byte by:
    
    LOOP FROM 1 TO 5:
    EACH_DISTANCE = "Mirror Byte" - EACH_BYTE
    
    So each distance looks like this:
                   +------+------+------+------+------+
                   | 0x1d | -0x5 | -0x59| 0x00 | 0x15 |
                   +------+------+------+------+------+
                   
    Then the program will calculate each "Encrypted Byte" by adding the distance with the "Mirror Byte", makes the "Encrypted Piece" looks like it's "Mirrored" by the "Mirror Key".
    
    This is How they Calculate:
    
    LOOP FROM 1 TO 5:
    
    EACH_ENCRYPTED_BYTE = "Mirror Byte" + EACH_DISTANCE
    
    So each "Encrypted Byte" looks like this:
                   +------+------+------+------+------+
                   | 0x4c | 0x2a | -0x2a| 0x2f | 0x44 |
                   +------+------+------+------+------+
                   
    Because Byte data cannot be minus, so add 256(0x100) to -0x2a, euqals to 0xd6
    
                   +------+------+------+------+------+
                   | 0x4c | 0x2a | 0xd6 | 0x2f | 0x44 |
                   +------+------+------+------+------+
                   
    Finally, the "Encrypted Piece" will be written to the encrypted file.
    
    
    
    
<br />
<br />
This is a clear list shows data processing:

                   +------+------+------+------+------+
    Original:      | 0x12 | 0x34 | 0x88 | 0x2f | 0x1a |
                   +------+------+------+------+------+
                   
    Calculate distance
                   
                   +------+------+------+------+------+
    Mirror:        | 0x2f | 0x2f | 0x2f | 0x2f | 0x2f |
                   +------+------+------+------+------+
                   
    Add distance
                   
                   +------+------+------+------+------+
    Encrypted:     | 0x4c | 0x2a | 0xd6 | 0x2f | 0x44 |
                   +------+------+------+------+------+
                   
    
    
    
<br />
<br />
Anyone would try many times to hack this piece without knowing "Length Byte" and "Mirror Byte", the number of "Length Byte" is totally unknown without mirror key, so it is well-encrypted.
<br />
<br />
However, as you can see, if one of the Byte equals to the "Mirror Byte", like the the 4th data of the original piece (0x2f), it is left un-encrypted. So the Encrypted File may have similarity with the Original File with Leaked Data. This is considered a security bug and I might fix it later in newer version.
<br />
<br />
Now I will answer you question. It is not REALLY secure, it DEPENDS. Let me give you some suggestion about using my program.
<br />
<br />
DO NOT use it if your file:
<br />
<br />
1. is very small. Larger than 100KB is recommended.
<br />
<br />
2. has long repeated content like "aaaaaaaaaaaaaaaaaaaa", "xxxxxxxxxxxxxx", "abc abc abc abc abc".
<br />
<br />
Also, choose you generated key wisely, encrypt command shows the percentage similarity for EACH PART, after that, shows the similarity between two files.
<br />
<br />
DO NOT use the key your encrypted file:
<br />
<br />
1. has similarity more than 5% from the original file.
<br />
<br />
2. the first part and the last part has similarity more than 1%. Because it might leak basic imformation.
<br />
<br />
3. any of the part has similarity more than 30%. This will makes hacking process easier.
<br />
<br />
<br />
<br />
That all. Enjoy it! Reporting bugs are also welcomed!
